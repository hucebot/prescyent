"""Module with functions and AutoPredictor class to init any predictor from prescyent.predictor from its config file"""
import json
from pathlib import Path
from typing import Any, Dict, Optional, Tuple, Type, Union

from lightning_fabric.utilities.types import _MAP_LOCATION_TYPE

from prescyent.predictor.config import PredictorConfig
from prescyent.predictor.constant_predictor import ConstantPredictor
from prescyent.predictor.delayed_predictor import DelayedPredictor
from prescyent.predictor.base_predictor import BasePredictor
from prescyent.predictor.lightning.configs.module_config import ModuleConfig
from prescyent.utils.errors import PredictorNotFound, PredictorUnprocessable
from prescyent.utils.logger import logger, PREDICTOR
from prescyent.predictor import PREDICTOR_MAP


def get_predictor_from_path(
    predictor_path: str, device: Optional[_MAP_LOCATION_TYPE] = None
):
    """helper function to create common baselines or autopredictor given string

    Args:
        predictor_path (str): path to a predictor or id of a baseline to load
        device (Optional[_MAP_LOCATION_TYPE], optional): device where to load checkpoint. Defaults to None.

    Returns:
        Any: instance of a predictor
    """

    if predictor_path == "" or predictor_path == "ConstantPredictor":
        return ConstantPredictor(None)
    if predictor_path == "DelayedPredictor":
        return DelayedPredictor(None)
    return AutoPredictor.load_pretrained(predictor_path, device)


def get_predictor_infos(config: Dict[str, Any]) -> Type[BasePredictor]:
    """retreive predictor class from a config

    Args:
        config (Dict[str, Any]): config data generated by the library

    Raises:
        AttributeError: could not find any matching predictor class from the config

    Returns:
        Type[BasePredictor]: retreived child class of a BasePredictor
    """

    predictor_class_name = config.get("name", None)
    if predictor_class_name is None:
        predictor_class_name = config.get("model_config", {}).get("name")
    predictor_class = PREDICTOR_MAP.get(predictor_class_name, None)
    if predictor_class is None:
        logger.getChild(PREDICTOR).error(
            "Could not find a predictor class matching %s",
            predictor_class_name,
        )
        raise AttributeError(predictor_class_name)
    return predictor_class


class AutoPredictor:
    """Auto class building the requested Predictor class from a configuration and the predictor map {predictor_name_str: predictor_class"""

    @classmethod
    def preprocess_config_attribute(
        cls, config: Union[str, Path, ModuleConfig, dict]
    ) -> Tuple[dict, str]:
        """turn some acceptable config format to a tuple of config_data and its path

        Args:
            config (Union[str, Path, ModuleConfig, dict]): config path or its data

        Raises:
            NotImplementedError: if the config class isn't supported

        Returns:
            Tuple[dict, str]: config_data and its path
        """

        if isinstance(config, (str, Path)):
            return cls._get_config_from_path(Path(config)), str(config)
        elif isinstance(config, ModuleConfig):
            return config.model_dump(), None
        elif isinstance(config, dict):
            return config, None
        else:
            raise NotImplementedError('Check your attr "config"\'s type')

    @classmethod
    def load_config(cls, path: Union[str, Path, ModuleConfig, dict]) -> PredictorConfig:
        """load the config of a predictor

        Args:
            path (Union[str, Path, ModuleConfig, dict]): config path or its data

        Returns:
            PredictorConfig: the config data
        """

        config, _ = cls.preprocess_config_attribute(path)
        predictor_class = get_predictor_infos(config)
        return predictor_class.config_class(**config.get("model_config", {}))

    @classmethod
    def load_pretrained(
        cls,
        config: Union[str, Path, dict, ModuleConfig],
        device: Optional[_MAP_LOCATION_TYPE] = None,
    ) -> BasePredictor:
        """load a predictor previously saved to disk, given its path

        Args:
            config (Union[str, Path, dict, ModuleConfig]): path to the predictor
            device (Optional[_MAP_LOCATION_TYPE], optional): device where to load checkpoint. Defaults to None.

        Returns:
            BasePredictor: loaded instance of a trained Predictor
        """

        config, config_path = cls.preprocess_config_attribute(config)
        predictor_class = get_predictor_infos(config)
        if config_path is None:
            logger.getChild(PREDICTOR).error("Missing model path info")
            logger.getChild(PREDICTOR).error(config)
        logger.getChild(PREDICTOR).info(
            "Loading %s from %s",
            predictor_class.PREDICTOR_NAME,
            config_path,
        )
        return predictor_class.load_pretrained(model_dir=config_path, device=device)

    @classmethod
    def build_from_config(
        cls, config: Union[str, Path, dict, ModuleConfig]
    ) -> BasePredictor:
        """instanciate a new predictor given a config

        Args:
            config (Union[str, Path, dict, ModuleConfig]): config or path to a config to create the predictor

        Returns:
            BasePredictor: new instance of a Predictor
        """

        config, _ = cls.preprocess_config_attribute(config)
        predictor_class = get_predictor_infos(config)
        logger.getChild(PREDICTOR).info(
            "Building new %s", predictor_class.PREDICTOR_NAME
        )
        return predictor_class(config=config)

    @classmethod
    def _get_config_from_path(cls, config_path: Path) -> Dict[str, Any]:
        """Method to resolve the config path, searching for .json files generated by the lib given the config_path attribute

        Args:
            config_path (Path): path of the file or directory

        Raises:
            PredictorNotFound: if no config file where found
            PredictorUnprocessable: if found config file doesn't contain the expected data

        Returns:
            Dict[str, Any]: the config data
        """

        if config_path.is_dir():
            config_path = config_path / "config.json"
        if not config_path.exists():
            exception = PredictorNotFound(
                message=f'No file or directory at "{config_path}"'
            )
            logger.getChild(PREDICTOR).error(exception)
            raise exception
        try:
            with config_path.open(encoding="utf-8") as conf_file:
                return json.load(conf_file)
        except json.JSONDecodeError as json_exception:
            exception = PredictorUnprocessable(
                message="The provided config_file" " could not be loaded as Json"
            )
            logger.getChild(PREDICTOR).error(exception)
            raise exception from json_exception
